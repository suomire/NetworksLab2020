# Лабораторная работа №2
## Разработка консольного чата на сокетах с использованием selectors
`selectors_server.py` - серверное приложение;
`сlient.py` - приложение-клиент;
`message_utils.py` - общие используемые функции;
`custom_colors.py` - файл с конструкциями для форматирования текста на вывод;

###  Описание работы
Приложения клиентов и сервера обмениваются между собой сообщениями следующего вида:
1. Заголовок -- начальная часть сообщения фиксированной длины (10 символов), которая содержит в себе информацию о длине сообщения;

2. Содержимое -- оставшаяся часть сообщения, ограничения на минимальную/максимальную длину отсутствуют, может содержать в себе либо служебную информацию от сервера, либо сообщение от другого клиента.
    1. Сообщение от клиента содержит время отправки, никнейм отправителя и текст сообщения. Эти части разделяются с помощью непечатного (при использовании Python3) символа `'\0'` на этапе финальном этапе перед отправкой сообщения.
    2. Служебное сообщение состоит из одной части, не содержит времени/никнейма.
    
В начале работы клиентсокого приложения запрашивается никнейм на ввод,
который после успешного подключения к серверу сразу же отправляется сообщением.
Если сервер успешно обрабатывает поступившее подключение,
то пользователю отправляется welcome-message с информацией о способе корректного выхода (ввод `"<quit<"`).
После этого все введенные сообщения будут отправлены в чат (кроме пустых строк).

Для завершения работы пользователь может либо ввести комбинацию для выхода, либо аварийно завершить с помощью `"Ctrl+C"`.
В обоих случаях программа-клиент завершается без ошибок, а программа-сервер корректно обрабатывает эти ситуации
и не прерыввает свою работу. Завершение работы сервера происходит при нажатии `"Ctrl+C"`.
В этом случае программа-сервер обрабатывает запрос на остановку работы, рассылает всем клиентам уведомление о завершении
работы сервера, закрывает серверный и все клиентские сокеты. Завершается работа закрытием основного потока,
которое приводит к остановке всех клиентских потоков-демонов. 

Улучшение читабельности достигается за счет добавления форматирования текста.
Серверные сообщения выводятся красным цветом и жирным шрифтом. 
Цвет фрагментов со временем отправления и текста пользовательского сообщения не меняется,
никней всегда подсвечивается случайным цветом.

Работа со временем происходит только на стороне клиента. 
При отправке сообщения дата + время + часовой пояс добавляются в его начало, 
а при получении и распаковке сообщения время переводится в часовой пояс получателя с помощью библиотек `pytz`, `tzlocal`

Суть задания состоит в том, чтобы использовать при обработке поведения клиентов неблокирующие сокеты. 
Такие сокеты при исполнении блокирующих операций (send, recv, connect, accept) возвращают 
управление главному потоку исполнения еще до завершения своей обработки. 
Механизм poll реализован с помощью модуля `selectors`.

Сначала создается сокет, потом в выбранном selector (в случае моей работы был выбрал `DefaultSelector`,
именно он выполняет механизм `epoll`) сокет регистрируется для мониторинга `I/O events`.
Первым был зарегистрирован серверный сокет. 
В вызове `selector.register` указывается объект для мониторинга, события, 
которые ожидаются на регистрируемом объекте и опционально обработчик, 
который должен выполнится при возникновении события на прослушиваемом объекте. 
Для серверного и клиентских сокетов ожидалось событие для чтения, 
но обработчики были разные.

В сервере также появился механизм буферизации сообщений. 
Сообщение не всегда приходит полностью. 
Если входящее сообщение очень большое оно будет отправляться частями
и для его обработки нужен буфер, 
который будет объединять полученные части сообщений для разных клиентов. 
Когда сообщение получено полностью, то оно удаляется из буфера, 
а если сообщение получено полностью сразу, то оно туда и не заносится.



